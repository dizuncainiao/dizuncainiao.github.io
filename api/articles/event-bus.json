{"title":"Event Bus","uid":"e27ca51324eb3fbf12d00b0c949efce4","slug":"event-bus","date":"2021-12-23T07:47:51.000Z","updated":"2021-12-24T11:28:21.417Z","comments":true,"path":"api/articles/event-bus.json","keywords":"帝尊菜鸟个人博客，帝尊菜鸟个人网站，web前端，JavaScript，CSS，HTML","cover":[],"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我们都知道在 Vue 中父子组件通信使用 <code>props</code>、<code>$emit</code>，兄弟组件或者跨组件之间可以通过 <code>Vuex</code> 或 <code>EventBus</code> ，包括 <code>$parent</code> 、<code>$root</code> 和 <code>$refs</code> 都是可以达到通信的目的，总之 Vue 组件之间的通信方式非常丰富。</p>\n<p>今天的主角是<code>EventBus</code> ，那么先谈谈我对它的理解。</p>\n<p><code>EventBus</code> 之所以能实现全局跨组件通信首先因为它是一个全局对象，可以通过挂在 <code>window</code> 或 <code>Vue.prototype</code> 上，并且能通过触发事件传参来实现数据的传递。</p>\n<p>在小型项目（二三十个页面）中使用起来还是比较友好的，比起 <code>Vuex</code> 要来的简单粗暴一点。因为 <code>Vuex</code> 需要建立 <code>mutations</code> 、<code>actions</code> ，某些逻辑交互甚至需要借助 <code>computed</code> + <code>watch</code> 来实现，这在小项目中显得比较臃肿。</p>\n<p>在大型项目（几百个页面）中使用 <code>EventBus</code> 不是不行，就是这里面水很深，很难把握的住……</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021050719014288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpenVuY2Fpbmlhbw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><code>EventBus</code> 的缺点就是 <code>Vuex</code> 的优点，缺乏 <strong>状态管理</strong> 。试想一下我们在看一段代码时，看到 <code>$emit(&#39;someEvent&#39;)</code> 或  <code>$on(&#39;someEvent&#39;)</code>后想要知道它分别在哪里被监听，在哪里被触发，然后全局一搜竟然有几十处，这……😵</p>\n<p>但这并不意味着 <code>EventBus</code> 在大型项目中就不能用，二者结合起来用才是最香的。比如这样的场景：<strong>根据父组件中导航菜单的开合状态在子组件中处理一些逻辑</strong> ，类似于这样的场景使用 <code>EventBus</code> 是不是要简单粗暴一点，触发个事件就解决了。<code>EventBus</code> 比较适合在那种 <strong>定向的</strong>、<strong>耦合度较低</strong> 的功能场景中使用。</p>\n<p>对于 <code>Vuex</code> 和 <code>EventBus</code> 之间我觉得基本上能够相互替代，但是不能完美替代。这两者在我的日常开发中都是缺一不可的，但是就是这么好用的 <code>EventBus</code>  在 <a href=\"https://v3.cn.vuejs.org/guide/migration/events-api.html#%E4%BA%8B%E4%BB%B6-api\">Vue3</a> 中被移除了，怎么办🤔，嗯。。。要不写一个？</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><p>做任何事情都是分步骤的，把大象装进冰箱里还分成 3 步呢，那么写一个 <code>EventBus</code> 可以分为以下步骤：</p>\n<ul>\n<li><p><code>on</code> 用来监听当前实例上的自定义事件。事件可以由 <code>emit</code> 触发。回调函数会接收所有传入事件触发函数的额外参数。</p>\n</li>\n<li><p><code>once</code> 监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</p>\n</li>\n<li><p><code>off</code> 移除自定义事件监听器。</p>\n<ul>\n<li>如果没有提供参数，则移除所有的事件监听器；</li>\n<li>如果只提供了事件，则移除该事件所有的监听器；</li>\n<li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li>\n</ul>\n</li>\n<li><p><code>emit</code> 触发当前实例上的事件。附加参数都会传给监听器回调。</p>\n</li>\n</ul>\n<p>为了尽量 1:1 模拟出 Vue2 中的用法，这里就直接照搬了 Vue2 中的 <a href=\"https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6\">#实例方法-事件</a> 。有了步骤以后实现一个 <code>EventBus</code> 就已经完成了一大半了，下面待我慢慢道来。</p>\n<h2 id=\"事件监听-on\"><a href=\"#事件监听-on\" class=\"headerlink\" title=\"事件监听-on\"></a>事件监听-on</h2><p><code>on</code> 方法传入两个参数，第一个是 <strong>事件</strong> <em>string</em> ，第二个是 <strong>回调函数</strong> 。<code>on</code> 与其说是事件监听，不如将它理解为 <strong>注册</strong> 、<strong>登记</strong> ，因为 <code>on</code> 的核心就是将 <strong>事件</strong> 以及对应的 <strong>回调</strong> 收集供 <code>emit</code> 触发。实现代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class DzEmitter &#123;\n    _events &#x3D; &#123;&#125;\n\n    static addEvent(e, callback, isOnce &#x3D; false) &#123;\n        const &#123;_events&#125; &#x3D; this\n        const keys &#x3D; Object.keys(_events)\n        if (keys.includes(e)) &#123;\n            _events[e].isOnce &#x3D; isOnce\n            _events[e].callbacks.push(callback)\n        &#125; else &#123;\n            _events[e] &#x3D; &#123;\n                isOnce,\n                callbacks: [callback]\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 监听当前实例上的自定义事件\n    on(e, callback) &#123;\n        DzEmitter.addEvent.call(this, e, callback)\n    &#125;\n&#125;</code></pre>\n\n<p>这里使用 <code>_events</code> 来收集 <strong>事件</strong> 与 <strong>回调</strong> 。需要注意的是，一个 <strong>事件</strong> 可以对应多个 <strong>回调</strong> ，因此要加以处理下。一个注册了多个相同事件的 <code>_events</code> 数据如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const _events &#x3D; &#123;\n    selfClick: &#123;\n        isOnce: true,\n        callbacks: [fn, fn2]\n    &#125;\n&#125;</code></pre>\n\n<p><code>isOnce</code> 是用来判断注册来源是 <code>once</code> 还是 <code>on</code> 。</p>\n<h2 id=\"事件触发-emit\"><a href=\"#事件触发-emit\" class=\"headerlink\" title=\"事件触发-emit\"></a>事件触发-emit</h2><p><code>emit</code> 传入两个参数，第一个是 <strong>事件</strong> <em>string</em> ，第二个是 <strong>传给回调的参数</strong> 。其核心就是根据 <strong>事件名称</strong> ，把参数传给 <strong>回调</strong> ，并调用 <strong>回调函数</strong> 就行了。根据上面的 <code>_events</code> 数据，写出以下代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 触发当前实例上的事件。附加参数都会传给监听器回调。\nemit(e, data) &#123;\n    try &#123;\n        const &#123;callbacks, isOnce&#125; &#x3D; this._events[e]\n        callbacks.forEach(fn &#x3D;&gt; fn(data))\n        isOnce &amp;&amp; this.off(e)\n    &#125; catch (e) &#123;\n        console.error(e)\n    &#125;\n&#125;</code></pre>\n\n<p>因为一个 <strong>事件</strong> 对应多个 <strong>回调</strong> ，所以触发事件时它对应的数个回调要一同调用。由 <code>once</code> 注册的事件需要在第一次调用后销毁掉。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>关于 <code>once</code> 和 <code>off</code> 就不单独讲了，直接上全部代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class DzEmitter &#123;\n    _events &#x3D; &#123;&#125;\n\n    static addEvent(e, callback, isOnce &#x3D; false) &#123;\n        const &#123;_events&#125; &#x3D; this\n        const keys &#x3D; Object.keys(_events)\n        if (keys.includes(e)) &#123;\n            _events[e].isOnce &#x3D; isOnce\n            _events[e].callbacks.push(callback)\n        &#125; else &#123;\n            _events[e] &#x3D; &#123;\n                isOnce,\n                callbacks: [callback]\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 触发当前实例上的事件。附加参数都会传给监听器回调。\n    emit(e, data) &#123;\n        try &#123;\n            const &#123;callbacks, isOnce&#125; &#x3D; this._events[e]\n            callbacks.forEach(fn &#x3D;&gt; fn(data))\n            isOnce &amp;&amp; this.off(e)\n        &#125; catch (e) &#123;\n            console.error(e)\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 监听当前实例上的自定义事件\n    on(e, callback) &#123;\n        DzEmitter.addEvent.call(this, e, callback)\n    &#125;\n\n    &#x2F;&#x2F; 监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除\n    once(e, callback) &#123;\n        DzEmitter.addEvent.call(this, e, callback, true)\n    &#125;\n\n    &#x2F;&#x2F; 移除自定义事件监听器\n    off(e, callback) &#123;\n        &#x2F;&#x2F; 如果没有提供参数，则移除所有的事件监听器\n        if (!arguments.length) &#123;\n            this._events &#x3D; &#123;&#125;\n        &#125;\n\n        &#x2F;&#x2F; 如果只提供了事件，则移除该事件所有的监听器\n        if (e &amp;&amp; !callback) &#123;\n            delete this._events[e]\n        &#125;\n\n        &#x2F;&#x2F; 如果同时提供了事件与回调，则只移除这个回调的监听器\n        if (e &amp;&amp; callback) &#123;\n            const &#123;callbacks&#125; &#x3D; this._events[e]\n            const index &#x3D; callbacks.findIndex(fn &#x3D;&gt; fn &#x3D;&#x3D;&#x3D; callback)\n            index &gt;&#x3D; 0 &amp;&amp; callbacks.splice(index, 1)\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>以上基本 1:1 模拟了 vue2 中的 <code>EventBus</code>  （ps：移除了数组传参的方式），将它设为一个全局对象后就能实现事件的监听和触发，从而实现全局通信。基本用法如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const emitter &#x3D; new DzEmitter()\n\nconst onClickFn &#x3D; data &#x3D;&gt; &#123;\n\tconsole.log(&#39;on-1&#39;, data);\n&#125;\nconst onClickFn2 &#x3D; data &#x3D;&gt; &#123;\n\tconsole.log(&#39;on-2&#39;, data);\n&#125;\nconst onceClickFn &#x3D; data &#x3D;&gt; &#123;\n\tconsole.log(&#39;once-1&#39;, data);\n&#125;\n\nemitter.on(&#39;onClick&#39;, onClickFn)\nemitter.on(&#39;onClick&#39;, onClickFn2)\nemitter.once(&#39;onceClick&#39;, onceClickFn)\n\n&#x2F;&#x2F; emitter.off(&#39;onClick&#39;, onClickFn2)\n&#x2F;&#x2F; emitter.off(&#39;onClick&#39;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n    emitter.emit(&#39;onClick&#39;, &#96;触发事件：onClick&#96;)\n    emitter.emit(&#39;onceClick&#39;, &#96;触发事件：onceClick&#96;)\n    console.log(emitter);\n&#125;, 1000)</code></pre>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上便是我尝试写一个 <code>EventBus</code> 的全部了，整体代码量还是非常少的。猜测一下尤大在 Vue3 中移除 <code>EventBus</code> 的原因，可能是出于更好的性能考虑吧，也有可能是为了更贴切我们日常的编程直觉吧。毕竟实现一个简单的 <code>EventBus</code> 需要生成一个复杂的 Vue 实例感觉不是太好（ps：不纯粹，会有太多不相干的属性方法），借助于一些专注的库来实现这个功能应该会更好。<br>以上代码仅用于交流分享，请不要用在实际开发中，出了问题本人概不负责🤣🤣。 想要在 Vue3 中使用 <code>EventBus</code> 功能的，请看它的 <a href=\"https://v3.cn.vuejs.org/guide/migration/events-api.html#%E8%BF%81%E7%A7%BB%E7%AD%96%E7%95%A5\">官方推荐</a> 。</p>\n","feature":true,"text":"前言我们都知道在 Vue 中父子组件通信使用 props、$emit，兄弟组件或者跨组件之间可以通过 Vuex 或 EventBus ，包括 $parent 、$root 和 $refs 都是可以达到通信的目的，总之 Vue 组件之间的通信方式非常丰富。 今天的主角是EventB...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">步骤</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-on\"><span class=\"toc-text\">事件监听-on</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91-emit\"><span class=\"toc-text\">事件触发-emit</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">完整代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Greedy Snake","uid":"506ca00e65144df18d66801c0d8409c9","slug":"greedy-snake","date":"2021-12-23T07:47:51.000Z","updated":"2021-12-24T11:28:21.417Z","comments":true,"path":"api/articles/greedy-snake.json","keywords":"帝尊菜鸟个人博客，帝尊菜鸟个人网站，web前端，JavaScript，CSS，HTML","cover":[],"text":"效果图最近使用 JS 写了一个贪吃蛇游戏，效果如下： 谷歌浏览器点击直接在线玩 前言贪吃蛇作为一款经典又简单的小游戏，每个人都玩过。实现一个贪吃蛇游戏基本具有以下功能： 棋盘（也被称作 “地图”，我这里画的像一个围棋棋盘，索性就叫棋盘） 蛇 （细致一点分为：蛇头、蛇身、蛇尾） 方...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{}}