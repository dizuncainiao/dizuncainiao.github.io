{"title":"Greedy Snake","uid":"506ca00e65144df18d66801c0d8409c9","slug":"greedy-snake","date":"2021-12-23T07:47:51.000Z","updated":"2021-12-24T11:28:21.417Z","comments":true,"path":"api/articles/greedy-snake.json","keywords":"帝尊菜鸟个人博客，帝尊菜鸟个人网站，web前端，JavaScript，CSS，HTML","cover":[],"content":"<h2 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h2><p>最近使用 JS 写了一个贪吃蛇游戏，效果如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210416221615434.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><a href=\"https://dizuncainiao.gitee.io/dz-greedysnake/\">谷歌浏览器点击直接在线玩</a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>贪吃蛇作为一款经典又简单的小游戏，每个人都玩过。实现一个贪吃蛇游戏基本具有以下功能：</p>\n<ul>\n<li>棋盘（也被称作 “地图”，我这里画的像一个围棋棋盘，索性就叫棋盘）</li>\n<li>蛇 （细致一点分为：蛇头、蛇身、蛇尾）</li>\n<li>方向（上下左右）控制，并且自动行走</li>\n<li>碰撞检测（撞墙、撞自己）</li>\n<li>食物在随机位置生成</li>\n<li>蛇吃到食物，尾部生长一截</li>\n</ul>\n<p>以上也便是我的实现步骤了，下面分享一些更详细的实现思路。</p>\n<h2 id=\"棋盘\"><a href=\"#棋盘\" class=\"headerlink\" title=\"棋盘\"></a>棋盘</h2><p>棋盘就是蛇运动的区域，简陋一点甚至可以不要边框，但是为了更好的游戏体验，这里还是加上边框。但是此边框非彼边框，使用 <code>border</code> 来实现效果图中的边框也可以，但这里我采用了其他的方式，比如 <strong>背景色</strong> ，看下图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210416221635387.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>通过层级、定位，使得黑块成为了蓝块视觉上的边框，然后结合 <code>grid</code> 网格布局实现 <strong>格格分明</strong> 的棋盘便尤为简单。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210416221657600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpenVuY2Fpbmlhbw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>这里一个大块采用 <strong>黑色背景</strong> ，400个小块采用 <strong>白色背景</strong> ，使用 <code>grid</code> 布局横、纵分别 20 个依次排列，再加上网格的行、列间距，便能形成围棋棋盘式的布局。这里的黑线实则就是 <strong>遮挡+间隙</strong> 形成的，代码如下：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;style&gt;\n&#x2F;&#x2F; 大块\n#checkerboard &#123;\n    display: grid;\n    grid-template-columns: repeat(20, 16px);\n    grid-template-rows: repeat(20, 16px);\n    grid-column-gap: 1px;\n    grid-row-gap: 1px;\n    padding: 1px;\n    background: #000;\n&#125;\n\n&#x2F;&#x2F; 小块\n.square &#123;\n    background: #fff;\n&#125;\n&lt;&#x2F;style&gt;</code></pre>\n\n<p>因为是 <code>grid</code> 布局，所有一些 <strong>上古浏览器</strong> 就不能玩这个游戏了。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021041622172663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpenVuY2Fpbmlhbw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"坐标\"><a href=\"#坐标\" class=\"headerlink\" title=\"坐标\"></a>坐标</h2><p>很多游戏都有坐标的概念，贪吃蛇支持自动行走、食物生成在随机位置以及碰撞检测等功能都是依据坐标来实现的。</p>\n<p>我这里的坐标实现很简单：第一行第一个格子坐标为 <strong>1-1</strong>，第一行最后一个格子坐标为 <strong>1-20</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210416221959668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpenVuY2Fpbmlhbw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>在生成 <code>div</code> 时将每一个格子 <strong>对应的坐标</strong> 通过 <strong>css类名</strong> 对应起来，代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * 棋盘 20 * 20\n * 坐标：1-1, ... 1-20, ... 20-20\n *&#x2F;\nclass Checkerboard &#123;\n    constructor(container, gridNum) &#123;\n        this.container &#x3D; container\n        this.gridNum &#x3D; gridNum\n        this.generate()\n    &#125;\n\n    &#x2F;&#x2F; 每个格子类名为：SX轴坐标_Y轴坐标 S1_20\n    generate() &#123;\n        const fragment &#x3D; document.createDocumentFragment()\n        for (let i &#x3D; 0; i &lt; this.gridNum; i++) &#123;\n            for (let j &#x3D; 0; j &lt; this.gridNum; j++) &#123;\n                const grid &#x3D; document.createElement(&#39;div&#39;)\n                grid.classList.add(&#39;square&#39;, &#96;S$&#123;j + 1&#125;_$&#123;i + 1&#125;&#96;)\n                fragment.appendChild(grid)\n            &#125;\n        &#125;\n        this.container.appendChild(fragment)\n    &#125;\n&#125;</code></pre>\n<p>这样第一行第一个 <code>div</code> 的类名是 <code>S1_1</code>，第一行最后一个 <code>div</code> 的类名为 <code>S1_20</code>。可以这么说，这个 <font color=red><strong>css 类名的设计就是这个游戏的核心设计</strong></font> ，因为后续的自动行走、食物生成在随机位置以及碰撞检测等功能全部都是在操作 <strong>css类名</strong> 。</p>\n<p>更详细代码可以在底部查看源码~</p>\n<h2 id=\"蛇、食物的绘制\"><a href=\"#蛇、食物的绘制\" class=\"headerlink\" title=\"蛇、食物的绘制\"></a>蛇、食物的绘制</h2><p>很多时候采用 <strong>CSS 样式</strong> 结合 <strong>css类名</strong> 的切换能更好、更快、更高性能的实现动画或者其他的逻辑。那么在这里 <strong>蛇</strong> 和 <strong>食物</strong> 绘制我直接通过加 <strong>css类名</strong> 就解决了，代码如下：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;style&gt;\n.square &#123;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: #fff;\n&#125;\n\n.snake::after &#123;\n    display: block;\n    content: &#39;&#39;;\n    width: 70%;\n    height: 70%;\n    border-radius: 100%;\n    background: #9bbef8;\n&#125;\n\n.snake.head::after &#123;\n    background: #0037ff;\n&#125;\n\n.snake.tail::after &#123;\n    background: #7400d2;\n&#125;\n\n.food::after &#123;\n    display: block;\n    content: &#39;&#39;;\n    width: 70%;\n    height: 70%;\n    border-radius: 100%;\n    background: #d54830;\n&#125;\n&lt;&#x2F;style&gt;</code></pre>\n\n<p>将相应的 <strong>css 类名</strong> 加在 <code>.square</code> 上就生成了蛇和食物了，粗暴一点伪元素可以不用，这里为了美观一点使用 <strong>伪元素+圆角</strong> 修饰一下。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210416221757763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpenVuY2Fpbmlhbw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Y7fVKbEn-1618582608058)(E:\\gitStore\\blog-md\\纯JS实现贪吃蛇——超上瘾小游戏\\image-20210416200314757.png)]\"></p>\n<h2 id=\"蛇的行走-amp-碰撞检测-amp-吃到食物\"><a href=\"#蛇的行走-amp-碰撞检测-amp-吃到食物\" class=\"headerlink\" title=\"蛇的行走 &amp; 碰撞检测 &amp; 吃到食物\"></a>蛇的行走 &amp; 碰撞检测 &amp; 吃到食物</h2><p>以上三个功能都是依据坐标来实现的，索性放在一起讲</p>\n<h4 id=\"蛇的行走\"><a href=\"#蛇的行走\" class=\"headerlink\" title=\"蛇的行走\"></a>蛇的行走</h4><p><img src=\"https://img-blog.csdnimg.cn/20210416221826799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpenVuY2Fpbmlhbw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>就如上图所示，实现蛇的行走其实非常简单，这里只需要想懂一点即可：<strong>每次移动，除了蛇头坐标(蓝色圆点)是一个全新的坐标，其他圆点的坐标都是它之前的那一个坐标</strong> 。这里蛇的原始坐标是 <code>[&#39;12-13&#39;, &#39;11-13&#39;, &#39;10-13&#39;]</code> ，那么它往右走的话只要将 <code>13-13</code> 作为蛇头坐标即可，上一段模拟代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const arr &#x3D; [&#39;12-13&#39;, &#39;11-13&#39;, &#39;10-13&#39;]\n\n&#x2F;&#x2F; 删除蛇尾坐标\narr.pop()\n\n&#x2F;&#x2F; 加入新的蛇头坐标\narr.unshift(&#39;13-13&#39;)\n\n&#x2F;&#x2F; arr &#x3D;&gt; [&#39;13-13&#39;, &#39;12-13&#39;, &#39;11-13&#39;]</code></pre>\n\n<p>蛇尾坐标肯定要删的，不然蛇不吃食物都能生长了，可以脑补一下画面~</p>\n<p>在一开始生成棋盘的时候，每个 <strong>格子(div)</strong> 都已经绑定上与坐标相对应的 <strong>css类名</strong> ，这里根据上面的坐标数组将相应的 div  <strong>添加/移除css类名</strong> 即可。</p>\n<h4 id=\"碰撞检测\"><a href=\"#碰撞检测\" class=\"headerlink\" title=\"碰撞检测\"></a>碰撞检测</h4><p><img src=\"https://img-blog.csdnimg.cn/20210416221842838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpenVuY2Fpbmlhbw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><strong>碰撞检测</strong> 听起来好像 ”一头雾水😲😲什么东东😱😱“，但是一个贪吃蛇游戏的碰撞检测还能有多难。原理其实就是这样：蛇只能在棋盘内活动，蛇存在的 <strong>有效坐标</strong> 也只能包含在棋盘内。这里横纵坐标最小、最大值分别是 <strong>1 、20</strong>， 只需要判断 <strong>蛇头坐标</strong> 是否在 <strong>1-20</strong> 以内(包含1和20)就可以了。</p>\n<h4 id=\"吃到食物\"><a href=\"#吃到食物\" class=\"headerlink\" title=\"吃到食物\"></a>吃到食物</h4><p>吃到食物其实也是碰撞检测的一种，判断 <strong>新的蛇头坐标</strong> 和 <strong>食物坐标</strong> 一样即为吃到食物，并且会在当前蛇尾周围可用坐标中随机生成一个新的蛇尾坐标，如下图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210416221900703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpenVuY2Fpbmlhbw==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>当蛇头和食物重合后，淡蓝的圆点便成了新的蛇尾坐标，并且会在红色箭头所示的坐标中随机选一个当做新的蛇尾坐标。需要注意的是 <strong>新的蛇尾坐标</strong> 可能会不存在，那么此时就 game over 了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>更多代码也就不贴了，以上也基本将这个小游戏的核心都讲遍了，关于 <strong>模式</strong> 实则是坐标的另一种简单运用罢了，<strong>难度</strong> 更仅仅是定时器的时间改变而已。还有很多想法后续有时间再实现吧，如下：</p>\n<ul>\n<li>等级称号（达成相应的分数来实现相应的称号，比如：初出茅庐……）</li>\n<li>加速功能（按住空格键来根据定时器的时间实现加速）</li>\n<li>存档功能（按住个什么键保存当前蛇的坐标、模式等信息，存入本地缓存，下次再玩）</li>\n<li>周期性出现一个 <strong>大食物</strong> 一次长好几节</li>\n<li>等等等等~</li>\n</ul>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><a href=\"https://gitee.com/dizuncainiao/dz-greedysnake\">https://gitee.com/dizuncainiao/dz-greedysnake</a></p>\n","feature":true,"text":"效果图最近使用 JS 写了一个贪吃蛇游戏，效果如下： 谷歌浏览器点击直接在线玩 前言贪吃蛇作为一款经典又简单的小游戏，每个人都玩过。实现一个贪吃蛇游戏基本具有以下功能： 棋盘（也被称作 “地图”，我这里画的像一个围棋棋盘，索性就叫棋盘） 蛇 （细致一点分为：蛇头、蛇身、蛇尾） 方...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%88%E6%9E%9C%E5%9B%BE\"><span class=\"toc-text\">效果图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A3%8B%E7%9B%98\"><span class=\"toc-text\">棋盘</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9D%90%E6%A0%87\"><span class=\"toc-text\">坐标</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%9B%87%E3%80%81%E9%A3%9F%E7%89%A9%E7%9A%84%E7%BB%98%E5%88%B6\"><span class=\"toc-text\">蛇、食物的绘制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%9B%87%E7%9A%84%E8%A1%8C%E8%B5%B0-amp-%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B-amp-%E5%90%83%E5%88%B0%E9%A3%9F%E7%89%A9\"><span class=\"toc-text\">蛇的行走 &amp; 碰撞检测 &amp; 吃到食物</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%9B%87%E7%9A%84%E8%A1%8C%E8%B5%B0\"><span class=\"toc-text\">蛇的行走</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">碰撞检测</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%83%E5%88%B0%E9%A3%9F%E7%89%A9\"><span class=\"toc-text\">吃到食物</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">源码</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"TypeScript infer","uid":"53f040a798a170ca18dea5684f0540a9","slug":"ts-infer","date":"2021-12-23T09:33:00.000Z","updated":"2021-12-24T11:28:21.418Z","comments":true,"path":"api/articles/ts-infer.json","keywords":"帝尊菜鸟个人博客，帝尊菜鸟个人网站，web前端，JavaScript，CSS，HTML","cover":null,"text":"前言TypeScript 是微软开发的一个开源的编程语言，通过在 JavaScript 的基础上添加静态类型定义构建而成。它是 JavaScript 的超集，不仅支持原生JS的写法，还增加了很多有用、强大的功能。众所周知， JavaScript 是弱类型语言，一些很低级却难以发现...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Event Bus","uid":"e27ca51324eb3fbf12d00b0c949efce4","slug":"event-bus","date":"2021-12-23T07:47:51.000Z","updated":"2021-12-24T11:28:21.417Z","comments":true,"path":"api/articles/event-bus.json","keywords":"帝尊菜鸟个人博客，帝尊菜鸟个人网站，web前端，JavaScript，CSS，HTML","cover":[],"text":"前言我们都知道在 Vue 中父子组件通信使用 props、$emit，兄弟组件或者跨组件之间可以通过 Vuex 或 EventBus ，包括 $parent 、$root 和 $refs 都是可以达到通信的目的，总之 Vue 组件之间的通信方式非常丰富。 今天的主角是EventB...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}