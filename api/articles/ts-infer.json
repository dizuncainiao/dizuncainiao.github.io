{"title":"TypeScript infer","uid":"53f040a798a170ca18dea5684f0540a9","slug":"ts-infer","date":"2021-12-23T09:33:00.000Z","updated":"2021-12-24T11:28:21.418Z","comments":true,"path":"api/articles/ts-infer.json","keywords":"帝尊菜鸟个人博客，帝尊菜鸟个人网站，web前端，JavaScript，CSS，HTML","cover":null,"content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://www.typescriptlang.org/\">TypeScript</a> 是微软开发的一个开源的编程语言，通过在 JavaScript 的基础上添加静态类型定义构建而成。它是 JavaScript 的超集，不仅支持原生JS的写法，还增加了很多有用、强大的功能。众所周知， JavaScript 是弱类型语言，一些很低级却难以发现的 Bug 只有在运行时才能发现，而 TypeScript 却能够在编写代码的过程中就能避免绝大部分的低级报错。本专栏用于记录和分享我在使用 TypeScript 中的感悟和心得，以下来介绍一下 <code>infer</code> 的用法：</p>\n<h2 id=\"infer-关键字\"><a href=\"#infer-关键字\" class=\"headerlink\" title=\"infer 关键字\"></a>infer 关键字</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在有条件类型的 <code>extends</code> 子语句中，允许出现 <code>infer</code> 声明，它会引入一个待推断的类型变量。 这个推断的类型变量可以在有条件类型的 true 分支中被引用。</p></blockquote>\n<p>这就是 <code>infer</code> 的解释，是不是上来一看就有点懵。晦涩的描述从字面意思来看确实很难懂，通过分解知识点以及结合一些例子后就很好理解了。首先看一下什么是条件类型：</p>\n<h2 id=\"条件类型\"><a href=\"#条件类型\" class=\"headerlink\" title=\"条件类型\"></a>条件类型</h2><p>像这样 <code>T extends U ? X : Y</code> 的表达式就是条件类型，结合以下代码：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type ConditionType&lt;T&gt; &#x3D; T extends Boolean ? number : undefined\n\nconst a: boolean &#x3D; false\nconst b: string &#x3D; &#39;false&#39;\n\ntype TypeA &#x3D; typeof a &#x2F;&#x2F; boolean\ntype TypeB &#x3D; typeof b &#x2F;&#x2F; string\n\ntype T1 &#x3D; ConditionType&lt;TypeA&gt; &#x2F;&#x2F; number\ntype T2 &#x3D; ConditionType&lt;TypeB&gt; &#x2F;&#x2F; undefined</code></pre>\n\n<p><code>ConditionType</code> 是我定义的一个简单的工具类型，它可以接收一个 <strong>泛型参数 T</strong>，并分别返回不同的类型。以上第一行代码可以理解为：如果 <code>T</code> 是布尔类型则返回 <code>number</code> 类型，不是则返回 <code>undefined</code> 类型。甚至，我们还可以约束传入的 <strong>泛型参数 T</strong> 的类型，让我们的代码更严谨一点，如下：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type Types &#x3D; boolean | string\ntype ConditionType&lt;T extends Types&gt; &#x3D; T extends Boolean ? number : undefined\n\ntype TypeC &#x3D; object\ntype T3 &#x3D; ConditionType&lt;TypeC&gt; &#x2F;&#x2F; Error: Type &#39;object&#39; does not satisfy the constraint &#39;Types&#39;. </code></pre>\n\n<p>通过对泛型参数类型的约束，传入其他类型会报错。</p>\n<h2 id=\"ReturnType（获取函数返回值类型）\"><a href=\"#ReturnType（获取函数返回值类型）\" class=\"headerlink\" title=\"ReturnType（获取函数返回值类型）\"></a>ReturnType（获取函数返回值类型）</h2><p>结合 Typescript 内置工具类型 <code>ReturnType</code> 来理解 “使用 <code>infer</code> 关键字来声明一个待推断的类型变量”。<code>ReturnType</code> 可以获取函数返回值类型，它的核心也是 <code>infer</code> 来实现的，代码如下：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * Obtain the return type of a function type\n *&#x2F;\ntype ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: any) &#x3D;&gt; infer R ? R : any;</code></pre>\n\n<p>它的用法非常简单，如下：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const add &#x3D; (x: number, y: number) &#x3D;&gt; x + y\n\ntype Type1 &#x3D; typeof add &#x2F;&#x2F; (x: number, y: number) &#x3D;&gt; number\ntype T1 &#x3D; ReturnType&lt;Type1&gt; &#x2F;&#x2F; number</code></pre>\n\n<p><code>T extends (...args: any) =&gt; any</code> 这一行代码就是约束传入 <code>ReturnType</code> 的泛型参数类型必须是函数类型，这就类似于参数校验。这里的 <code>T</code> 就是 <code>add</code> 函数的类型 <code>(x: number, y: number) =&gt; number</code> 。</p>\n<p>那么 <code>T extends (...args: any) =&gt; infer R ? R : any</code> 代码的含义可以理解为：如果 T <em>(x: number, y: number) =&gt; number</em> 满足于 (…args: any) =&gt; infer R 的表现形式的话，就返回 R，否则返回 <code>any</code> 。</p>\n<p><code>infer R</code> 表示声明一个待推断的类型，并将推断出来的类型存储在 R 中。这里 T 是 <code>(x: number, y: number) =&gt; number</code> ，<code>infer R</code> 被放在 <code>(...args: any) =&gt; infer R</code> 函数类型的返回值处，因此推断出了 <code>number</code> 类型并赋值给 R 。</p>\n<h2 id=\"infer-推断函数参数类型\"><a href=\"#infer-推断函数参数类型\" class=\"headerlink\" title=\"infer 推断函数参数类型\"></a>infer 推断函数参数类型</h2><p><code>ReturnType</code> 借助 <code>infer</code> 实现获取函数的返回值类型，那么如何获取函数参数类型？虽然 TypeScript 已实现该工具函数，但不妨碍我们写一个。很简单，在 <code>ReturnType</code>  上改一下即可：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type ParamsType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: infer R) &#x3D;&gt; any ? R : any;</code></pre>\n\n<p>仅是将 <code>infer R</code> 跟参数类型 <code>any</code> 调换一下就实现了，看下打印：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type ParamsType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: infer R) &#x3D;&gt; any ? R : any;\n\nconst add &#x3D; (a: number, b: string) &#x3D;&gt; a + b\n\n\ntype TypeAdd &#x3D; typeof add &#x2F;&#x2F; (a: number, b: string) &#x3D;&gt; string\n\ntype T1 &#x3D; ParamsType&lt;TypeAdd&gt; &#x2F;&#x2F; [number, string]\n\nconst arr: T1 &#x3D; [1, 2] &#x2F;&#x2F; Error: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>由于上述采用的是 ES6 rest 参数写法，所以它会推断出一个元组类型，如果是想获取单个参数类型可以这样写：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">type ParamType&lt;T extends (arg: any) &#x3D;&gt; any&gt; &#x3D; T extends (arg: infer R) &#x3D;&gt; any ? R : any;</code></pre>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上便是我对于 <code>infer</code> 的粗浅理解，其实 <code>infer</code> 很强大能实现更多的功能。比如：将类构造函数类型的参数推断为元组的 <code>ConstructorParameters</code> 、获取构造函数类型的返回类型的 <code>InstanceType</code> ，还能通过 <code>infer</code> 推断出数组的子元素类型等等一系列骚操作……</p>\n<p>并且 Vue3 中的 <code>ref</code> 为什么能够实现各种复杂的类型推断，也是通过 <code>infer</code> 来实现的，写的有点复杂，感兴趣的童鞋可以看一下 <a href=\"https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts\">Vue3 ref 源码</a>  。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.tslang.cn/docs/release-notes/typescript-2.8.html\">https://www.tslang.cn/docs/release-notes/typescript-2.8.html</a></li>\n<li><a href=\"https://www.wenjiangs.com/doc/typescript-infer\">https://www.wenjiangs.com/doc/typescript-infer</a></li>\n</ul>\n","feature":true,"text":"前言TypeScript 是微软开发的一个开源的编程语言，通过在 JavaScript 的基础上添加静态类型定义构建而成。它是 JavaScript 的超集，不仅支持原生JS的写法，还增加了很多有用、强大的功能。众所周知， JavaScript 是弱类型语言，一些很低级却难以发现...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#infer-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">infer 关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">条件类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ReturnType%EF%BC%88%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89\"><span class=\"toc-text\">ReturnType（获取函数返回值类型）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#infer-%E6%8E%A8%E6%96%AD%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">infer 推断函数参数类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Greedy Snake","uid":"506ca00e65144df18d66801c0d8409c9","slug":"greedy-snake","date":"2021-12-23T07:47:51.000Z","updated":"2021-12-24T11:28:21.417Z","comments":true,"path":"api/articles/greedy-snake.json","keywords":"帝尊菜鸟个人博客，帝尊菜鸟个人网站，web前端，JavaScript，CSS，HTML","cover":[],"text":"效果图最近使用 JS 写了一个贪吃蛇游戏，效果如下： 谷歌浏览器点击直接在线玩 前言贪吃蛇作为一款经典又简单的小游戏，每个人都玩过。实现一个贪吃蛇游戏基本具有以下功能： 棋盘（也被称作 “地图”，我这里画的像一个围棋棋盘，索性就叫棋盘） 蛇 （细致一点分为：蛇头、蛇身、蛇尾） 方...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}