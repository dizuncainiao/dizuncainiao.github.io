[{"id":"53f040a798a170ca18dea5684f0540a9","title":"TypeScript infer","content":"前言TypeScript 是微软开发的一个开源的编程语言，通过在 JavaScript 的基础上添加静态类型定义构建而成。它是 JavaScript 的超集，不仅支持原生JS的写法，还增加了很多有用、强大的功能。众所周知， JavaScript 是弱类型语言，一些很低级却难以发现的 Bug 只有在运行时才能发现，而 TypeScript 却能够在编写代码的过程中就能避免绝大部分的低级报错。本专栏用于记录和分享我在使用 TypeScript 中的感悟和心得，以下来介绍一下 infer 的用法：\ninfer 关键字\n\n\n\n\n\n\n\n\n在有条件类型的 extends 子语句中，允许出现 infer 声明，它会引入一个待推断的类型变量。 这个推断的类型变量可以在有条件类型的 true 分支中被引用。\n这就是 infer 的解释，是不是上来一看就有点懵。晦涩的描述从字面意思来看确实很难懂，通过分解知识点以及结合一些例子后就很好理解了。首先看一下什么是条件类型：\n条件类型像这样 T extends U ? X : Y 的表达式就是条件类型，结合以下代码：\ntype ConditionType&lt;T&gt; &#x3D; T extends Boolean ? number : undefined\n\nconst a: boolean &#x3D; false\nconst b: string &#x3D; &#39;false&#39;\n\ntype TypeA &#x3D; typeof a &#x2F;&#x2F; boolean\ntype TypeB &#x3D; typeof b &#x2F;&#x2F; string\n\ntype T1 &#x3D; ConditionType&lt;TypeA&gt; &#x2F;&#x2F; number\ntype T2 &#x3D; ConditionType&lt;TypeB&gt; &#x2F;&#x2F; undefined\n\nConditionType 是我定义的一个简单的工具类型，它可以接收一个 泛型参数 T，并分别返回不同的类型。以上第一行代码可以理解为：如果 T 是布尔类型则返回 number 类型，不是则返回 undefined 类型。甚至，我们还可以约束传入的 泛型参数 T 的类型，让我们的代码更严谨一点，如下：\ntype Types &#x3D; boolean | string\ntype ConditionType&lt;T extends Types&gt; &#x3D; T extends Boolean ? number : undefined\n\ntype TypeC &#x3D; object\ntype T3 &#x3D; ConditionType&lt;TypeC&gt; &#x2F;&#x2F; Error: Type &#39;object&#39; does not satisfy the constraint &#39;Types&#39;. \n\n通过对泛型参数类型的约束，传入其他类型会报错。\nReturnType（获取函数返回值类型）结合 Typescript 内置工具类型 ReturnType 来理解 “使用 infer 关键字来声明一个待推断的类型变量”。ReturnType 可以获取函数返回值类型，它的核心也是 infer 来实现的，代码如下：\n&#x2F;**\n * Obtain the return type of a function type\n *&#x2F;\ntype ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: any) &#x3D;&gt; infer R ? R : any;\n\n它的用法非常简单，如下：\nconst add &#x3D; (x: number, y: number) &#x3D;&gt; x + y\n\ntype Type1 &#x3D; typeof add &#x2F;&#x2F; (x: number, y: number) &#x3D;&gt; number\ntype T1 &#x3D; ReturnType&lt;Type1&gt; &#x2F;&#x2F; number\n\nT extends (...args: any) =&gt; any 这一行代码就是约束传入 ReturnType 的泛型参数类型必须是函数类型，这就类似于参数校验。这里的 T 就是 add 函数的类型 (x: number, y: number) =&gt; number 。\n那么 T extends (...args: any) =&gt; infer R ? R : any 代码的含义可以理解为：如果 T (x: number, y: number) =&gt; number 满足于 (…args: any) =&gt; infer R 的表现形式的话，就返回 R，否则返回 any 。\ninfer R 表示声明一个待推断的类型，并将推断出来的类型存储在 R 中。这里 T 是 (x: number, y: number) =&gt; number ，infer R 被放在 (...args: any) =&gt; infer R 函数类型的返回值处，因此推断出了 number 类型并赋值给 R 。\ninfer 推断函数参数类型ReturnType 借助 infer 实现获取函数的返回值类型，那么如何获取函数参数类型？虽然 TypeScript 已实现该工具函数，但不妨碍我们写一个。很简单，在 ReturnType  上改一下即可：\ntype ParamsType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: infer R) &#x3D;&gt; any ? R : any;\n\n仅是将 infer R 跟参数类型 any 调换一下就实现了，看下打印：\ntype ParamsType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: infer R) &#x3D;&gt; any ? R : any;\n\nconst add &#x3D; (a: number, b: string) &#x3D;&gt; a + b\n\n\ntype TypeAdd &#x3D; typeof add &#x2F;&#x2F; (a: number, b: string) &#x3D;&gt; string\n\ntype T1 &#x3D; ParamsType&lt;TypeAdd&gt; &#x2F;&#x2F; [number, string]\n\nconst arr: T1 &#x3D; [1, 2] &#x2F;&#x2F; Error: Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n\n由于上述采用的是 ES6 rest 参数写法，所以它会推断出一个元组类型，如果是想获取单个参数类型可以这样写：\ntype ParamType&lt;T extends (arg: any) &#x3D;&gt; any&gt; &#x3D; T extends (arg: infer R) &#x3D;&gt; any ? R : any;\n\n总结以上便是我对于 infer 的粗浅理解，其实 infer 很强大能实现更多的功能。比如：将类构造函数类型的参数推断为元组的 ConstructorParameters 、获取构造函数类型的返回类型的 InstanceType ，还能通过 infer 推断出数组的子元素类型等等一系列骚操作……\n并且 Vue3 中的 ref 为什么能够实现各种复杂的类型推断，也是通过 infer 来实现的，写的有点复杂，感兴趣的童鞋可以看一下 Vue3 ref 源码  。\n参考\nhttps://www.tslang.cn/docs/release-notes/typescript-2.8.html\nhttps://www.wenjiangs.com/doc/typescript-infer\n\n","slug":"ts-infer","date":"2021-12-23T09:33:00.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"506ca00e65144df18d66801c0d8409c9","title":"Greedy Snake","content":"效果图最近使用 JS 写了一个贪吃蛇游戏，效果如下：\n\n谷歌浏览器点击直接在线玩\n前言贪吃蛇作为一款经典又简单的小游戏，每个人都玩过。实现一个贪吃蛇游戏基本具有以下功能：\n\n棋盘（也被称作 “地图”，我这里画的像一个围棋棋盘，索性就叫棋盘）\n蛇 （细致一点分为：蛇头、蛇身、蛇尾）\n方向（上下左右）控制，并且自动行走\n碰撞检测（撞墙、撞自己）\n食物在随机位置生成\n蛇吃到食物，尾部生长一截\n\n以上也便是我的实现步骤了，下面分享一些更详细的实现思路。\n棋盘棋盘就是蛇运动的区域，简陋一点甚至可以不要边框，但是为了更好的游戏体验，这里还是加上边框。但是此边框非彼边框，使用 border 来实现效果图中的边框也可以，但这里我采用了其他的方式，比如 背景色 ，看下图：\n\n通过层级、定位，使得黑块成为了蓝块视觉上的边框，然后结合 grid 网格布局实现 格格分明 的棋盘便尤为简单。\n\n这里一个大块采用 黑色背景 ，400个小块采用 白色背景 ，使用 grid 布局横、纵分别 20 个依次排列，再加上网格的行、列间距，便能形成围棋棋盘式的布局。这里的黑线实则就是 遮挡+间隙 形成的，代码如下：\n&lt;style&gt;\n&#x2F;&#x2F; 大块\n#checkerboard &#123;\n    display: grid;\n    grid-template-columns: repeat(20, 16px);\n    grid-template-rows: repeat(20, 16px);\n    grid-column-gap: 1px;\n    grid-row-gap: 1px;\n    padding: 1px;\n    background: #000;\n&#125;\n\n&#x2F;&#x2F; 小块\n.square &#123;\n    background: #fff;\n&#125;\n&lt;&#x2F;style&gt;\n\n因为是 grid 布局，所有一些 上古浏览器 就不能玩这个游戏了。\n\n坐标很多游戏都有坐标的概念，贪吃蛇支持自动行走、食物生成在随机位置以及碰撞检测等功能都是依据坐标来实现的。\n我这里的坐标实现很简单：第一行第一个格子坐标为 1-1，第一行最后一个格子坐标为 1-20\n\n在生成 div 时将每一个格子 对应的坐标 通过 css类名 对应起来，代码如下：\n&#x2F;**\n * 棋盘 20 * 20\n * 坐标：1-1, ... 1-20, ... 20-20\n *&#x2F;\nclass Checkerboard &#123;\n    constructor(container, gridNum) &#123;\n        this.container &#x3D; container\n        this.gridNum &#x3D; gridNum\n        this.generate()\n    &#125;\n\n    &#x2F;&#x2F; 每个格子类名为：SX轴坐标_Y轴坐标 S1_20\n    generate() &#123;\n        const fragment &#x3D; document.createDocumentFragment()\n        for (let i &#x3D; 0; i &lt; this.gridNum; i++) &#123;\n            for (let j &#x3D; 0; j &lt; this.gridNum; j++) &#123;\n                const grid &#x3D; document.createElement(&#39;div&#39;)\n                grid.classList.add(&#39;square&#39;, &#96;S$&#123;j + 1&#125;_$&#123;i + 1&#125;&#96;)\n                fragment.appendChild(grid)\n            &#125;\n        &#125;\n        this.container.appendChild(fragment)\n    &#125;\n&#125;\n这样第一行第一个 div 的类名是 S1_1，第一行最后一个 div 的类名为 S1_20。可以这么说，这个 css 类名的设计就是这个游戏的核心设计 ，因为后续的自动行走、食物生成在随机位置以及碰撞检测等功能全部都是在操作 css类名 。\n更详细代码可以在底部查看源码~\n蛇、食物的绘制很多时候采用 CSS 样式 结合 css类名 的切换能更好、更快、更高性能的实现动画或者其他的逻辑。那么在这里 蛇 和 食物 绘制我直接通过加 css类名 就解决了，代码如下：\n&lt;style&gt;\n.square &#123;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: #fff;\n&#125;\n\n.snake::after &#123;\n    display: block;\n    content: &#39;&#39;;\n    width: 70%;\n    height: 70%;\n    border-radius: 100%;\n    background: #9bbef8;\n&#125;\n\n.snake.head::after &#123;\n    background: #0037ff;\n&#125;\n\n.snake.tail::after &#123;\n    background: #7400d2;\n&#125;\n\n.food::after &#123;\n    display: block;\n    content: &#39;&#39;;\n    width: 70%;\n    height: 70%;\n    border-radius: 100%;\n    background: #d54830;\n&#125;\n&lt;&#x2F;style&gt;\n\n将相应的 css 类名 加在 .square 上就生成了蛇和食物了，粗暴一点伪元素可以不用，这里为了美观一点使用 伪元素+圆角 修饰一下。\n\n蛇的行走 &amp; 碰撞检测 &amp; 吃到食物以上三个功能都是依据坐标来实现的，索性放在一起讲\n蛇的行走\n就如上图所示，实现蛇的行走其实非常简单，这里只需要想懂一点即可：每次移动，除了蛇头坐标(蓝色圆点)是一个全新的坐标，其他圆点的坐标都是它之前的那一个坐标 。这里蛇的原始坐标是 [&#39;12-13&#39;, &#39;11-13&#39;, &#39;10-13&#39;] ，那么它往右走的话只要将 13-13 作为蛇头坐标即可，上一段模拟代码：\nconst arr &#x3D; [&#39;12-13&#39;, &#39;11-13&#39;, &#39;10-13&#39;]\n\n&#x2F;&#x2F; 删除蛇尾坐标\narr.pop()\n\n&#x2F;&#x2F; 加入新的蛇头坐标\narr.unshift(&#39;13-13&#39;)\n\n&#x2F;&#x2F; arr &#x3D;&gt; [&#39;13-13&#39;, &#39;12-13&#39;, &#39;11-13&#39;]\n\n蛇尾坐标肯定要删的，不然蛇不吃食物都能生长了，可以脑补一下画面~\n在一开始生成棋盘的时候，每个 格子(div) 都已经绑定上与坐标相对应的 css类名 ，这里根据上面的坐标数组将相应的 div  添加/移除css类名 即可。\n碰撞检测\n碰撞检测 听起来好像 ”一头雾水😲😲什么东东😱😱“，但是一个贪吃蛇游戏的碰撞检测还能有多难。原理其实就是这样：蛇只能在棋盘内活动，蛇存在的 有效坐标 也只能包含在棋盘内。这里横纵坐标最小、最大值分别是 1 、20， 只需要判断 蛇头坐标 是否在 1-20 以内(包含1和20)就可以了。\n吃到食物吃到食物其实也是碰撞检测的一种，判断 新的蛇头坐标 和 食物坐标 一样即为吃到食物，并且会在当前蛇尾周围可用坐标中随机生成一个新的蛇尾坐标，如下图：\n\n当蛇头和食物重合后，淡蓝的圆点便成了新的蛇尾坐标，并且会在红色箭头所示的坐标中随机选一个当做新的蛇尾坐标。需要注意的是 新的蛇尾坐标 可能会不存在，那么此时就 game over 了。\n总结更多代码也就不贴了，以上也基本将这个小游戏的核心都讲遍了，关于 模式 实则是坐标的另一种简单运用罢了，难度 更仅仅是定时器的时间改变而已。还有很多想法后续有时间再实现吧，如下：\n\n等级称号（达成相应的分数来实现相应的称号，比如：初出茅庐……）\n加速功能（按住空格键来根据定时器的时间实现加速）\n存档功能（按住个什么键保存当前蛇的坐标、模式等信息，存入本地缓存，下次再玩）\n周期性出现一个 大食物 一次长好几节\n等等等等~\n\n源码https://gitee.com/dizuncainiao/dz-greedysnake\n","slug":"greedy-snake","date":"2021-12-23T07:47:51.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"e27ca51324eb3fbf12d00b0c949efce4","title":"Event Bus","content":"前言我们都知道在 Vue 中父子组件通信使用 props、$emit，兄弟组件或者跨组件之间可以通过 Vuex 或 EventBus ，包括 $parent 、$root 和 $refs 都是可以达到通信的目的，总之 Vue 组件之间的通信方式非常丰富。\n今天的主角是EventBus ，那么先谈谈我对它的理解。\nEventBus 之所以能实现全局跨组件通信首先因为它是一个全局对象，可以通过挂在 window 或 Vue.prototype 上，并且能通过触发事件传参来实现数据的传递。\n在小型项目（二三十个页面）中使用起来还是比较友好的，比起 Vuex 要来的简单粗暴一点。因为 Vuex 需要建立 mutations 、actions ，某些逻辑交互甚至需要借助 computed + watch 来实现，这在小项目中显得比较臃肿。\n在大型项目（几百个页面）中使用 EventBus 不是不行，就是这里面水很深，很难把握的住……\n\nEventBus 的缺点就是 Vuex 的优点，缺乏 状态管理 。试想一下我们在看一段代码时，看到 $emit(&#39;someEvent&#39;) 或  $on(&#39;someEvent&#39;)后想要知道它分别在哪里被监听，在哪里被触发，然后全局一搜竟然有几十处，这……😵\n但这并不意味着 EventBus 在大型项目中就不能用，二者结合起来用才是最香的。比如这样的场景：根据父组件中导航菜单的开合状态在子组件中处理一些逻辑 ，类似于这样的场景使用 EventBus 是不是要简单粗暴一点，触发个事件就解决了。EventBus 比较适合在那种 定向的、耦合度较低 的功能场景中使用。\n对于 Vuex 和 EventBus 之间我觉得基本上能够相互替代，但是不能完美替代。这两者在我的日常开发中都是缺一不可的，但是就是这么好用的 EventBus  在 Vue3 中被移除了，怎么办🤔，嗯。。。要不写一个？\n步骤做任何事情都是分步骤的，把大象装进冰箱里还分成 3 步呢，那么写一个 EventBus 可以分为以下步骤：\n\non 用来监听当前实例上的自定义事件。事件可以由 emit 触发。回调函数会接收所有传入事件触发函数的额外参数。\n\nonce 监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。\n\noff 移除自定义事件监听器。\n\n如果没有提供参数，则移除所有的事件监听器；\n如果只提供了事件，则移除该事件所有的监听器；\n如果同时提供了事件与回调，则只移除这个回调的监听器。\n\n\nemit 触发当前实例上的事件。附加参数都会传给监听器回调。\n\n\n为了尽量 1:1 模拟出 Vue2 中的用法，这里就直接照搬了 Vue2 中的 #实例方法-事件 。有了步骤以后实现一个 EventBus 就已经完成了一大半了，下面待我慢慢道来。\n事件监听-onon 方法传入两个参数，第一个是 事件 string ，第二个是 回调函数 。on 与其说是事件监听，不如将它理解为 注册 、登记 ，因为 on 的核心就是将 事件 以及对应的 回调 收集供 emit 触发。实现代码如下：\nclass DzEmitter &#123;\n    _events &#x3D; &#123;&#125;\n\n    static addEvent(e, callback, isOnce &#x3D; false) &#123;\n        const &#123;_events&#125; &#x3D; this\n        const keys &#x3D; Object.keys(_events)\n        if (keys.includes(e)) &#123;\n            _events[e].isOnce &#x3D; isOnce\n            _events[e].callbacks.push(callback)\n        &#125; else &#123;\n            _events[e] &#x3D; &#123;\n                isOnce,\n                callbacks: [callback]\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 监听当前实例上的自定义事件\n    on(e, callback) &#123;\n        DzEmitter.addEvent.call(this, e, callback)\n    &#125;\n&#125;\n\n这里使用 _events 来收集 事件 与 回调 。需要注意的是，一个 事件 可以对应多个 回调 ，因此要加以处理下。一个注册了多个相同事件的 _events 数据如下：\nconst _events &#x3D; &#123;\n    selfClick: &#123;\n        isOnce: true,\n        callbacks: [fn, fn2]\n    &#125;\n&#125;\n\nisOnce 是用来判断注册来源是 once 还是 on 。\n事件触发-emitemit 传入两个参数，第一个是 事件 string ，第二个是 传给回调的参数 。其核心就是根据 事件名称 ，把参数传给 回调 ，并调用 回调函数 就行了。根据上面的 _events 数据，写出以下代码：\n&#x2F;&#x2F; 触发当前实例上的事件。附加参数都会传给监听器回调。\nemit(e, data) &#123;\n    try &#123;\n        const &#123;callbacks, isOnce&#125; &#x3D; this._events[e]\n        callbacks.forEach(fn &#x3D;&gt; fn(data))\n        isOnce &amp;&amp; this.off(e)\n    &#125; catch (e) &#123;\n        console.error(e)\n    &#125;\n&#125;\n\n因为一个 事件 对应多个 回调 ，所以触发事件时它对应的数个回调要一同调用。由 once 注册的事件需要在第一次调用后销毁掉。\n完整代码关于 once 和 off 就不单独讲了，直接上全部代码：\nclass DzEmitter &#123;\n    _events &#x3D; &#123;&#125;\n\n    static addEvent(e, callback, isOnce &#x3D; false) &#123;\n        const &#123;_events&#125; &#x3D; this\n        const keys &#x3D; Object.keys(_events)\n        if (keys.includes(e)) &#123;\n            _events[e].isOnce &#x3D; isOnce\n            _events[e].callbacks.push(callback)\n        &#125; else &#123;\n            _events[e] &#x3D; &#123;\n                isOnce,\n                callbacks: [callback]\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 触发当前实例上的事件。附加参数都会传给监听器回调。\n    emit(e, data) &#123;\n        try &#123;\n            const &#123;callbacks, isOnce&#125; &#x3D; this._events[e]\n            callbacks.forEach(fn &#x3D;&gt; fn(data))\n            isOnce &amp;&amp; this.off(e)\n        &#125; catch (e) &#123;\n            console.error(e)\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 监听当前实例上的自定义事件\n    on(e, callback) &#123;\n        DzEmitter.addEvent.call(this, e, callback)\n    &#125;\n\n    &#x2F;&#x2F; 监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除\n    once(e, callback) &#123;\n        DzEmitter.addEvent.call(this, e, callback, true)\n    &#125;\n\n    &#x2F;&#x2F; 移除自定义事件监听器\n    off(e, callback) &#123;\n        &#x2F;&#x2F; 如果没有提供参数，则移除所有的事件监听器\n        if (!arguments.length) &#123;\n            this._events &#x3D; &#123;&#125;\n        &#125;\n\n        &#x2F;&#x2F; 如果只提供了事件，则移除该事件所有的监听器\n        if (e &amp;&amp; !callback) &#123;\n            delete this._events[e]\n        &#125;\n\n        &#x2F;&#x2F; 如果同时提供了事件与回调，则只移除这个回调的监听器\n        if (e &amp;&amp; callback) &#123;\n            const &#123;callbacks&#125; &#x3D; this._events[e]\n            const index &#x3D; callbacks.findIndex(fn &#x3D;&gt; fn &#x3D;&#x3D;&#x3D; callback)\n            index &gt;&#x3D; 0 &amp;&amp; callbacks.splice(index, 1)\n        &#125;\n    &#125;\n&#125;\n\n以上基本 1:1 模拟了 vue2 中的 EventBus  （ps：移除了数组传参的方式），将它设为一个全局对象后就能实现事件的监听和触发，从而实现全局通信。基本用法如下：\nconst emitter &#x3D; new DzEmitter()\n\nconst onClickFn &#x3D; data &#x3D;&gt; &#123;\n\tconsole.log(&#39;on-1&#39;, data);\n&#125;\nconst onClickFn2 &#x3D; data &#x3D;&gt; &#123;\n\tconsole.log(&#39;on-2&#39;, data);\n&#125;\nconst onceClickFn &#x3D; data &#x3D;&gt; &#123;\n\tconsole.log(&#39;once-1&#39;, data);\n&#125;\n\nemitter.on(&#39;onClick&#39;, onClickFn)\nemitter.on(&#39;onClick&#39;, onClickFn2)\nemitter.once(&#39;onceClick&#39;, onceClickFn)\n\n&#x2F;&#x2F; emitter.off(&#39;onClick&#39;, onClickFn2)\n&#x2F;&#x2F; emitter.off(&#39;onClick&#39;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n    emitter.emit(&#39;onClick&#39;, &#96;触发事件：onClick&#96;)\n    emitter.emit(&#39;onceClick&#39;, &#96;触发事件：onceClick&#96;)\n    console.log(emitter);\n&#125;, 1000)\n\n总结以上便是我尝试写一个 EventBus 的全部了，整体代码量还是非常少的。猜测一下尤大在 Vue3 中移除 EventBus 的原因，可能是出于更好的性能考虑吧，也有可能是为了更贴切我们日常的编程直觉吧。毕竟实现一个简单的 EventBus 需要生成一个复杂的 Vue 实例感觉不是太好（ps：不纯粹，会有太多不相干的属性方法），借助于一些专注的库来实现这个功能应该会更好。以上代码仅用于交流分享，请不要用在实际开发中，出了问题本人概不负责🤣🤣。 想要在 Vue3 中使用 EventBus 功能的，请看它的 官方推荐 。\n","slug":"event-bus","date":"2021-12-23T07:47:51.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"c8af577eb1799cd38418c5cf4bc0ffdc","title":"PM2 deploy","content":"前言Nuxt.js 是一个基于 Vue.js 的轻量级应用框架,可用来创建服务端渲染 (SSR) 应用，本篇来讲一下 如何使用 PM2 部署 Nuxt 应用。\n创建 Nuxt 应用对于如何创建 Nuxt 应用，这里不作赘述，这里建议直接参考 官网 的做法，使用 create-nuxt-app 就好，可以参照 这里 的说明来了解创建应用时的配置选项。\n创建成功后，查看 package.json 文件，发现 Nuxt 已内置多种预设命令：\n&#123;\n\t&quot;scripts&quot;: &#123;\n\t    &quot;dev&quot;: &quot;nuxt&quot;,\n\t    &quot;build&quot;: &quot;nuxt build&quot;,\n\t    &quot;start&quot;: &quot;nuxt start&quot;,\n\t    &quot;generate&quot;: &quot;nuxt generate&quot;,\n\t    &quot;lint:js&quot;: &quot;eslint --ext \\&quot;.js,.vue\\&quot; --ignore-path .gitignore .&quot;,\n\t    &quot;lint:style&quot;: &quot;stylelint \\&quot;**&#x2F;*.&#123;vue,css&#125;\\&quot; --ignore-path .gitignore&quot;,\n\t    &quot;prepare&quot;: &quot;husky install&quot;,\n\t    &quot;lint&quot;: &quot;yarn lint:js &amp;&amp; yarn lint:style&quot;\n\t&#125;\n&#125;\n\n运行 yarn build 会打包 nuxt 应用并在根目录生成 .nuxt 目录，此时运行 yarn start 命令后访问 http://localhost:3000/ 即可查看应用页面。\nPM2-进程守护了解 NodeJS 的人都知道，通过 CMD/PowerShell 开启的 Node 服务，在关闭 命令提示符 窗口后，服务就断开了，页面也就访问不了。那么这如何解决呢？解决这个问题需要我们来了解一下 PM2：\n\n\n\n\n\n\n\n\n\nPM2 是一个守护进程管理器，它将帮助您管理和保持您的应用程序在线。\nnpm install pm2@latest -g\n# or\nyarn global add pm2\n\n运行上述命令完成 pm2 的安装，接下来在项目根目录创建一个 ecosystem.config.js 文件，内容如下：\nmodule.exports &#x3D; &#123;\n  apps: [\n    &#123;\n      name: &#39;NuxtAppName&#39;,\n      exec_mode: &#39;cluster&#39;,\n      instances: &#39;max&#39;, &#x2F;&#x2F; Or a number of instances\n      script: &#39;.&#x2F;node_modules&#x2F;nuxt&#x2F;bin&#x2F;nuxt.js&#39;,\n      args: &#39;start&#39;\n    &#125;\n  ]\n&#125;\n\n好了，那么此时运行 pm2 start 后，你可以将任何 命令提示符 窗口关掉都可以访问 http://localhost:3000/ 查看到应用页面，只要你不重启电脑。\npm2-windows-startup-服务器重启后自动恢复 pm2 进程依据上述内容，那么问题来了，电脑或服务器重启后，应用访问不了怎么办？实际的生产服务器中可能会有很多应用服务同时运行，总不能服务器宕机重启后一一手动敲命令重启服务吧。这里我们肯定想要在服务器重启后自动恢复应用服务（在 windows 系统中实践下），那么了解一下 pm2-windows-startup ：\n安装npm install pm2-windows-startup -g\n# or\nyarn global add pm2-windows-startup\n\n添加注册表项pm2-startup install\n\n注意：第一次安装或重启时可能会被杀毒软件警告，允许即可。\n保存当前的进程列表在使用 pm2 start 启动服务后，使用 pm2 save 即可保存当前的进程列表。在重启电脑后访问 http://localhost:3000/ 依然可以看到应用页面。\n参考\nNuxt 官网 - 使用 PM2 部署 Nuxt \npm2-windows-startup - npm \nnuxt.js部署vue应用到服务端过程 \nPM2 官网 \n\n源码更多细节参考 源码\n","slug":"pm2-deploy","date":"2021-12-23T07:47:51.000Z","categories_index":"","tags_index":"","author_index":"Aurora"}]